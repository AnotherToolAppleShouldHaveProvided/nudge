#!/Library/nudge/Python.framework/Versions/3.8/bin/python3
# -*- coding: utf-8 -*-
'''nudge - python wrapper for major OS updates.'''
import json
import optparse
import os
import platform
import random
import re
import shutil
import subprocess
import sys
import tempfile
import time
import urllib.error
import urllib.request
import webbrowser
from datetime import datetime, timedelta
from distutils.version import LooseVersion
from urllib.parse import unquote, urlparse

import gurl
import objc

from AppKit import NSImage

from Foundation import (NSURL, NSBundle, NSData, NSDate, NSLog, NSObject,
                        NSString, NSTimer)

from timercontroler import timerController
from helpers import *
from builder import Builder

def main():
    '''Main thread'''
    nudge_path = os.path.dirname(os.path.realpath(__file__))
    opts, _ = get_parsed_options()

    if nudge_already_loaded():
        nudgelog('nudge already loaded!')
        exit(0)

    # Get the current username
    user_name, current_user_uid, _ = get_console_username_info()

    # Bail if we are not in a user session.
    if user_name in (None, 'loginwindow', '_mbsetupuser'):
        exit(0)

    # Part for enhanced enforcement of Nudge
    nudge_dismissed_count = 0
    acceptable_apps = [
        'com.apple.loginwindow',
        'com.apple.systempreferences',
        'org.python.python'
    ]

    # local json path - if it exists already, let's assume someone is bundling
    # it with their package. Otherwise check for it and use gurl.
    json_path = os.path.join(nudge_path, 'nudge.json')
    cleanup = True
    if os.path.isfile(json_path):
        cleanup = False
        json_raw = open(json_path).read()
    else:
        tmp_dir = tempfile.mkdtemp()
        tmp_json = os.path.join(tmp_dir, 'nudge.json')
        json_path = tmp_json
        json_raw = None
        if opts.jsonurl:
            json_url = opts.jsonurl
            # json data for gurl download
            json_data = {
                'url': json_url,
                'file': json_path,
                'name': 'nudge.json'
            }

            # Grab auth headers if they exist and update the json_data dict.
            if opts.headers:
                headers = {'Authorization': opts.headers}
                json_data.update({'additional_headers': headers})

            url_parse = urllib.parse.urlparse(json_url)
            if url_parse.scheme == 'file':
                # File resources should be handled natively
                try:
                    json_raw = urllib.request.urlopen(json_url).read()
                except urllib.error.URLError as err:
                    nudgelog(err)
                    shutil.rmtree(tmp_dir)
                    exit(1)
            else:
                # If the file doesn't exist, grab it and wait half a second to save.
                while not os.path.isfile(json_path):
                    nudgelog(('Starting download: %s' % (urllib.parse.unquote(
                        json_data['url']))))
                    downloadfile(json_data)
                    time.sleep(0.5)
        else:
            nudgelog('nudge JSON file not specified!')
            shutil.rmtree(tmp_dir)
            exit(1)

    # Load up file to grab all the items.
    if json_raw:
        nudge_json = json.loads(json_raw)
    else:
        nudge_json = json.loads(open(json_path).read())

    # Load nudge preferences
    nudge_prefs = nudge_json['preferences']
    # Setup nudge preferences and all defaults if not set
    button_title_text = nudge_prefs.get('button_title_text',
        'Ready to start the update?')
    button_sub_titletext = nudge_prefs.get('button_sub_titletext',
        'Click on the button below.')
    cut_off_date = nudge_prefs.get('cut_off_date', False)
    cut_off_date_warning = nudge_prefs.get('cut_off_date_warning', 3)
    days_between_notifications = nudge_prefs.get('days_between_notifications',
        0)
    dismissal_count_threshold = nudge_prefs.get('dismissal_count_threshold', 9999999)
    logo_path = nudge_prefs.get('logo_path', 'company_logo.png')
    main_subtitle_text = nudge_prefs.get('main_subtitle_text',
        'A friendly reminder from your local IT team')
    main_title_text = nudge_prefs.get('main_title_text', 'macOS Update')
    minimum_os_sub_build_version = nudge_prefs.get('minimum_os_sub_build_version', '10A00')
    minimum_os_version = nudge_prefs.get('minimum_os_version', '10.14.6')
    minimum_os_version_major = minimum_os_version.rsplit('.', 1)[0]
    more_info_url = nudge_prefs.get('more_info_url', False)
    no_timer = nudge_prefs.get('no_timer', False)
    paragraph1_text = nudge_prefs.get('paragraph1_text',
        'A fully up-to-date device is required to ensure that IT can your accurately protect your computer.')
    paragraph2_text = nudge_prefs.get('paragraph2_text',
        'If you do not update your computer, you may lose access to some items necessary for your day-to-day tasks.')
    paragraph3_text = nudge_prefs.get('paragraph3_text',
        'To begin the update, simply click on the button below and follow the provided steps.')
    paragraph_title_text = nudge_prefs.get('paragraph_title_text',
        'A security update is required on your machine.')
    path_to_app = nudge_prefs.get('path_to_app',
        '/Applications/Install macOS Mojave.app')
    screenshot_path = nudge_prefs.get('screenshot_path', 'update_ss.png')
    LOCAL_URL_FOR_UPGRADE = nudge_prefs.get('local_url_for_upgrade', False)
    timer_day_1 = nudge_prefs.get('timer_day_1', 600)
    timer_day_3 = nudge_prefs.get('timer_day_3', 7200)
    timer_elapsed = nudge_prefs.get('timer_elapsed', 10)
    timer_final = nudge_prefs.get('timer_final', 60)
    timer_initial = nudge_prefs.get('timer_initial', 14400)
    random_delay = nudge_prefs.get('random_delay', False)
    nudge_su_prefs = nudge_json.get('software_updates', [])
    update_minor = nudge_prefs.get('update_minor', False)
    update_minor_days = nudge_prefs.get('update_minor_days', 14)

    nudge =  Builder(nudge_path, path_to_app, more_info_url)

    # Start information
    nudgelog('Target OS version: %s ' % minimum_os_version)
    if update_minor:
        if minimum_os_sub_build_version == '10A00':
            update_minor = False
        else:
            nudgelog('Target OS subversion: %s' % minimum_os_sub_build_version)
    nudgelog('Dismissal count threshold: %s ' % dismissal_count_threshold)


    # cleanup the tmp stuff now
    if cleanup:
        nudgelog('Cleaning up temporary files...')
        shutil.rmtree(tmp_dir)

    if random_delay:
        delay = random.randint(1,1200)
        nudgelog('Delaying run for {} seconds...'.format(delay))
        time.sleep(delay)

    # If the admin put '10.14' and not '10.14.0' the major version will be '10'
    # so make sure this error doesn't happen and the comparison doesn't fail.
    if '.' not in minimum_os_version_major:
        minimum_os_version_major = minimum_os_version

    os_version = get_os_version()
    os_version_major = get_os_version_major()
    os_version_sub_build = get_os_sub_build_version()

    # Example 10.14.6 (18G103) >=  10.14.6 (18G84)
    if os_version_sub_build >= LooseVersion(minimum_os_sub_build_version) and update_minor:
        nudgelog('OS version sub build is higher or equal to the minimum threshold: %s' % str(os_version_sub_build))
        exit(0)
    # Example: 10.14.6 >= 10.14.6
    elif os_version >= LooseVersion(minimum_os_version) and not update_minor:
        nudgelog('OS version is higher or equal to the minimum threshold: %s' % str(os_version))
        exit(0)
    # Example: 10.14/10.14.0 >= 10.14
    elif os_version_major >= LooseVersion(minimum_os_version_major) and not update_minor:
        nudgelog('OS major version is higher or equal to the minimum threshold and minor updates not enabled: %s ' % str(os_version))
        exit(0)
    else:
        nudgelog('OS version is below the minimum threshold: %s' % str(os_version))
        if update_minor and LooseVersion(minimum_os_sub_build_version) > os_version_sub_build:
            nudgelog('OS version is below the minimum threshold subversion: %s' % str(os_version_sub_build))

    minor_updates_required = False

    # Start main logic on major and minor upgrades
    if LooseVersion(minimum_os_version_major) > os_version_major:
        # This is a major upgrade now and needs the app. We shouldn't
        # perform minor updates.
        if LOCAL_URL_FOR_UPGRADE:
            # Reassign the global path_to_app with the specified local
            # upgrade URL
            path_to_app = LOCAL_URL_FOR_UPGRADE
        else:
            if not os.path.exists(path_to_app):
                nudgelog('Update application not found! Exiting...')
                exit(1)
    else:
        # do minor version stuff
        if update_minor:
            nudgelog('Checking for minor updates.')
            swupd_output = download_apple_updates()
            if not swupd_output:
                nudgelog('Could not run softwareupdate')
                # Exit 0 as we might be offline
                # TODO: Check if we're offline to exit with the
                # appropriate code
                exit(0)

            if pending_apple_updates() == [] or pending_apple_updates() is None:
                nudgelog('No Software updates to install')
                set_pref('first_seen', None)
                set_pref('last_seen', None)
                exit(0)
            else:
                # There are pending updates
                first_seen = pref('first_seen')
                last_seen = pref('last_seen')
                path_to_app = update_app_path()

                apple_sus_prefs_path = '/Library/Preferences/com.apple.SoftwareUpdate'

                if pref('AutomaticCheckEnabled', apple_sus_prefs_path) and \
                pref('AutomaticDownload', apple_sus_prefs_path) and \
                pref('AutomaticallyInstallMacOSUpdates', apple_sus_prefs_path):
                    # Only care about updates needing a restart
                    swupd_output = subprocess.check_output(['/usr/sbin/softwareupdate', '-la'])
                    for line in swupd_output.splitlines():
                        if b'restart' in line.lower():
                            minor_updates_required = True
                            break
                else:
                    # required preferences for background updates aren't present, notify for all
                    minor_updates_required = True

                if not minor_updates_required:
                    nudgelog('Only updates that can be installed in the background pending.')
                    set_pref('first_seen', None)
                    set_pref('last_seen', None)
                    exit()
                # todo: Work out how long the user has to install it
                # todays_date = datetime.utcnow()
                # first_seen_strp = datetime.strptime(first_seen, '%Y-%m-%d %H:%M:%S +0000')
                # date_diff_seconds = (first_seen_strp - todays_date).total_seconds()
                # date_diff_days = int(round(date_diff_seconds / 86400))
                # print date_diff_days

                # Allow admin to not show nudge all the time
                if days_between_notifications > 0:
                    if first_seen and last_seen:
                        today = datetime.utcnow()
                        last_seen_strp = datetime.strptime(last_seen, '%Y-%m-%d %H:%M:%S +0000')
                        difference = today - last_seen_strp
                        nudgelog(str(difference.days))
                        if difference.days < days_between_notifications:
                            nudgelog('Last seen date is within notification threshold: %s ' % str(days_between_notifications))
                            exit(0)

                if not first_seen:
                    set_pref('first_seen', datetime.utcnow())
                    first_seen = pref('first_seen')

    # Use the paths defined, or default to pngs in the same local path of
    # nudge
    for index, path in enumerate([logo_path, screenshot_path]):
        if path in ('company_logo.png', 'update_ss.png'):
            local_png_path = os.path.join(
                nudge_path, path).replace(' ', '%20')
        else:
            local_png_path = os.path.join(path).replace(' ', '%20')
        foundation_nsurl_path = NSURL.URLWithString_(
            'file:' + local_png_path)
        foundation_nsdata = NSData.dataWithContentsOfURL_(
            foundation_nsurl_path)
        foundation_nsimage = NSImage.alloc().initWithData_(
            foundation_nsdata)
        if index == 0:
            nudge.nudge.views['image.companylogo'].setImage_(foundation_nsimage)
        else:
            nudge.nudge.views['image.updatess'].setImage_(foundation_nsimage)

    # Attach all the nib buttons to functions
    nudge.nudge.attach(nudge.button_update, 'button.update')
    nudge.nudge.attach(nudge.button_moreinfo, 'button.moreinfo')
    nudge.nudge.attach(nudge.button_ok, 'button.ok')
    nudge.nudge.attach(nudge.button_understand, 'button.understand')

    # Setup the UI fields
    nudge.nudge.views['field.titletext'].setStringValue_(main_title_text)
    nudge.nudge.views['field.subtitletext'].setStringValue_(main_subtitle_text)
    nudge.nudge.views['field.updatetext'].setStringValue_(paragraph_title_text)
    nudge.nudge.views['field.paragraph1'].setStringValue_(paragraph1_text)
    nudge.nudge.views['field.paragraph2'].setStringValue_(paragraph2_text)
    nudge.nudge.views['field.paragraph3'].setStringValue_(paragraph3_text)
    nudge.nudge.views['field.h1text'].setStringValue_(button_title_text)
    nudge.nudge.views['field.h2text'].setStringValue_(button_sub_titletext)

    # Dynamically set username and serialnumber
    nudge.nudge.views['field.username'].setStringValue_(str(user_name))
    nudge.nudge.views['field.serialnumber'].setStringValue_(str(get_serial()))
    nudge.nudge.views['field.updated'].setStringValue_('No')

    # Hide the more_info_url if it's not set
    if not more_info_url:
        nudge.views['button.moreinfo'].setHidden_(True)

    minimum_minor_update_days = get_minimum_minor_update_days(update_minor_days, pending_apple_updates(), nudge_su_prefs)
    if cut_off_date or (minor_updates_required and minimum_minor_update_days > 0):
        todays_date = datetime.utcnow()
        if not cut_off_date: # fix for minor updates logic
            cut_off_date_strp = todays_date + timedelta(days=minimum_minor_update_days)
        else:
            cut_off_date_strp = datetime.strptime(cut_off_date, '%Y-%m-%d-%H:%M')
        date_diff_seconds = (cut_off_date_strp - todays_date).total_seconds()
        date_diff_days = int(round(date_diff_seconds / 86400))

        if date_diff_seconds >= 0:
            nudge.nudge.views['field.daysremaining'].setStringValue_(
                date_diff_days)
        else:
            nudge.nudge.views['field.daysremaining'].setStringValue_(
                'Past date!')

        cut_off_warn = bool(date_diff_seconds < int(
            cut_off_date_warning) * 86400)

        # Setup our timer controller
        timer_controller = timerController.new()
        nudge.timer_controller = (
            timer_controller.
            initWithDC_AA_DCT_NO_(nudge_dismissed_count, acceptable_apps,
                dismissal_count_threshold, nudge))

        if date_diff_seconds <= 0:
            # If the cutoff date is over, get stupidly aggressive

            # Disable all buttons so the user cannot exit out of the
            # application, and have the Update Machine button appear
            nudge.nudge.views['button.ok'].setHidden_(True)
            nudge.nudge.views['button.understand'].setHidden_(True)

            # Bring back nudge to the foreground, every 10 seconds
            timer = float(timer_elapsed)
        elif date_diff_seconds <= 3600:
            # If the cutoff date is within one hour, get very agressive

            # Disable all buttons so the user cannot exit out of the
            # application
            nudge.nudge.views['button.ok'].setHidden_(True)
            nudge.nudge.views['button.understand'].setHidden_(True)

            # Bring back nudge to the foreground, every 60 seconds
            # (1 minute)
            timer = float(timer_final)
        elif date_diff_seconds <= 86400:
            # If the cutoff date is within 86,400 seconds (24 hours), start
            # getting more agressive

            # Disable the ok button and require users to press understand
            # button first
            nudge.nudge.views['button.ok'].setHidden_(True)

            # If the user doesn't close out of nudge, we want it to
            # reappear - bring back nudge to the foreground, every
            # 600 seconds (10 minutes)
            timer = float(timer_day_1)
        elif cut_off_warn:
            # If the cutoff date is within 259,200 seconds (72 hours) or
            # whatever the admin set, start getting a bit more agressive

            # Disable the ok button and require users to press understand
            # button first
            nudge.nudge.views['button.ok'].setHidden_(True)

            # If the user doesn't close out of nudge, we want it to
            # reappear - bring back nudge to the foreground, every
            # 7,200 seconds (2 hours)
            timer = float(timer_day_3)
        else:
            # If the cutoff date is over 259,200 seconds (72 hours),
            # don't be that aggressive

            # Only require the ok button to exit out of nudge
            nudge.nudge.views['button.ok'].setHidden_(False)
            nudge.nudge.views['button.understand'].setHidden_(True)

            # If the user doesn't close out of nudge, we want it to
            # reappear - bring back nudge to the foreground, every
            # 14,400 seconds (4 hours)
            timer = float(timer_initial)

        nudge.timer = (
            NSTimer
            .scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_(
                timer, nudge.timer_controller, 'activateWindow:', None, True))
    else:
        # If you elect not to use a cutoff date, then the UI will only
        # appear one time per run, and only use the ok button

        # Hide the fields used for the cutoff date
        nudge.nudge.views['field.daysremainingtext'].setHidden_(True)
        nudge.nudge.views['field.daysremaining'].setHidden_(True)

        # Only require the ok button to exit out of nudge
        nudge.nudge.views['button.ok'].setHidden_(False)
        nudge.nudge.views['button.understand'].setHidden_(True)

        timer = float(timer_day_3)
        date_diff_seconds = 1000000

    # Use cut off dates, but don't use the timer functionality
    if no_timer:
        nudge.timer.invalidate()
        nudgelog('Timer invalidated!')
    else:
        nudgelog('Timer is set to %s' % str(timer))

    # Set last_seen pref
    set_pref('last_seen', datetime.utcnow())
    last_seen = pref('last_seen')

    # Set up our window controller and delegate
    nudge.nudge.hidden = True
    nudge.nudge.run()


if __name__ == '__main__':
    main()
